/**
 * generated by Xtext 2.25.0
 */
package ru.iaie.reflexold.scoping;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.util.ArrayList;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import ru.iaie.reflexold.reflexOld.AssignmentExpression;
import ru.iaie.reflexold.reflexOld.EnumMember;
import ru.iaie.reflexold.reflexOld.ImportedVariableList;
import ru.iaie.reflexold.reflexOld.PrimaryExpression;
import ru.iaie.reflexold.reflexOld.ProcessVariable;
import ru.iaie.reflexold.reflexOld.Program;
import ru.iaie.reflexold.reflexOld.ReflexOldPackage;
import ru.iaie.reflexold.reflexOld.TimeAmountOrRef;
import ru.iaie.reflexold.utils.ReflexOldModelUtil;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class ReflexOldScopeProvider extends AbstractReflexOldScopeProvider {
  private final ReflexOldPackage ePackage = ReflexOldPackage.eINSTANCE;
  
  @Override
  public IScope getScope(final EObject ctx, final EReference ref) {
    if (((ctx instanceof ImportedVariableList) && Objects.equal(ref, this.ePackage.getImportedVariableList_Variables()))) {
      final Function1<ProcessVariable, Boolean> _function = (ProcessVariable it) -> {
        return Boolean.valueOf(ReflexOldModelUtil.isShared(it));
      };
      final Iterable<ProcessVariable> candidates = IterableExtensions.<ProcessVariable>filter(((ImportedVariableList) ctx).getProcess().getVariables(), _function);
      return Scopes.scopeFor(candidates);
    }
    if (((((ctx instanceof PrimaryExpression) && Objects.equal(ref, this.ePackage.getPrimaryExpression_Reference())) || 
      ((ctx instanceof AssignmentExpression) && Objects.equal(ref, this.ePackage.getAssignmentExpression_AssignVar()))) || 
      ((ctx instanceof TimeAmountOrRef) && Objects.equal(ref, this.ePackage.getTimeAmountOrRef_Ref())))) {
      return this.getIdReferenceScope(ctx);
    }
    return super.getScope(ctx, ref);
  }
  
  private IScope getIdReferenceScope(final EObject ctx) {
    final Program prog = EcoreUtil2.<Program>getContainerOfType(ctx, Program.class);
    final ru.iaie.reflexold.reflexOld.Process proc = EcoreUtil2.<ru.iaie.reflexold.reflexOld.Process>getContainerOfType(ctx, ru.iaie.reflexold.reflexOld.Process.class);
    final ArrayList<EObject> candidates = new ArrayList<EObject>();
    final Function1<ru.iaie.reflexold.reflexOld.Enum, EList<EnumMember>> _function = (ru.iaie.reflexold.reflexOld.Enum it) -> {
      return it.getEnumMembers();
    };
    Iterables.<EObject>addAll(candidates, Iterables.<EObject>concat(ListExtensions.<ru.iaie.reflexold.reflexOld.Enum, EList<EnumMember>>map(prog.getEnums(), _function)));
    candidates.addAll(prog.getConsts());
    if ((proc != null)) {
      candidates.addAll(proc.getVariables());
      candidates.addAll(ReflexOldModelUtil.getImportedVariables(proc));
    }
    return Scopes.scopeFor(candidates);
  }
}

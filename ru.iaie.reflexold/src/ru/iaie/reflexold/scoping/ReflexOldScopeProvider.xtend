/*
 * generated by Xtext 2.25.0
 */
package ru.iaie.reflexold.scoping;

import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import ru.iaie.reflexold.reflexOld.ReflexOldPackage
import ru.iaie.reflexold.reflexOld.ImportedVariableList

import static extension org.eclipse.xtext.EcoreUtil2.*
import static extension ru.iaie.reflexold.utils.ReflexOldModelUtil.*
import ru.iaie.reflexold.reflexOld.PrimaryExpression
import ru.iaie.reflexold.reflexOld.AssignmentExpression
import ru.iaie.reflexold.reflexOld.TimeAmountOrRef
import ru.iaie.reflexold.reflexOld.Program
import ru.iaie.reflexold.reflexOld.Process
import java.util.ArrayList

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class ReflexOldScopeProvider extends AbstractReflexOldScopeProvider {

	val ePackage = ReflexOldPackage.eINSTANCE

	override IScope getScope(EObject ctx, EReference ref) {
		if (ctx instanceof ImportedVariableList && ref == ePackage.importedVariableList_Variables) {
			val candidates = (ctx as ImportedVariableList).process.variables.filter[shared]
			return Scopes.scopeFor(candidates)
		}
		
		if (ctx instanceof PrimaryExpression && ref == ePackage.primaryExpression_Reference ||
			ctx instanceof AssignmentExpression && ref == ePackage.assignmentExpression_AssignVar ||
			ctx instanceof TimeAmountOrRef && ref == ePackage.timeAmountOrRef_Ref) {
			return getIdReferenceScope(ctx)		
		}
		
		return super.getScope(ctx, ref)
		//return IScope.NULLSCOPE;
	}	

	private def IScope getIdReferenceScope(EObject ctx) {
		val prog = ctx.getContainerOfType(Program)
		val proc = ctx.getContainerOfType(Process)
		
		val candidates = new ArrayList<EObject>
		candidates.addAll(prog.enums.map[enumMembers].flatten)
		candidates.addAll(prog.consts)
		if (proc !== null) {
			candidates.addAll(proc.variables)
			candidates.addAll(proc.importedVariables)
		}
		
		return Scopes.scopeFor(candidates)
	}

}
